# UI for the agent using ChainLit framework to make a chat window.
import chainlit as cl
import os
from datetime import datetime 
import httpx
"""
Set up the directory to save the output file generated by the agent.
"""
OUTPUT_DIR=os.path.join(os.getcwd(),"outputs")
os.makedirs(OUTPUT_DIR,exist_ok=True)

"""
Below contains the initial message the chat-bot sends the users way. 
It includes greetings, introduction of the bot and the details which the bot needs.
"""
@cl.on_chat_start
async def start():
    await cl.Message(
        content="Hello dear aspirant, I am your college advisor, here to help you.\n\n"
                "Tell me the details of the university you are targeting:\n"
                "* **University Name**\n"
                "* **Program Name**\n"
                "* **Level of study** (Bachelors, Masters, PhD)\n"
                "* **Background** (GPAm Country, College Tier etc.)\n"
                "When you provide me this information I will provide you with a document that comprises of strategy and information on the course you are aiming for!"
    ).send()

"""
Determines the steps after user responds with information. 
"""
@cl.on_message
async def main(message: cl.Message):
    # STEP 1: Extract the name of uni and the program name
    async with cl.Step(name="Identifying Target", type="tool") as step:
        async with httpx.AsyncClient() as client:
            response = await client.post(
                "http://127.0.0.1:8001/run-agent",
                json={"message": message.content},
                timeout=30  # Give LLM time to think
            )
            
            if response.status_code == 200:
                data = response.json()
                uni_name = data.get("university", "Unknown University")
                program_name = data.get("program", "Unknown Program")
                level=data.get("level","Bachelors")
                
                # Save data to session
                cl.user_session.set("uni", uni_name)
                cl.user_session.set("program", program_name)
                cl.user_session.set("level", level)

                # Format the UI output
                clean_name = f"{uni_name}-{program_name}".replace(" ", "-")
                step.output = f"Targeting: {uni_name} ({program_name})"
            

            else:
                step.output = "Error: Could not extract university details."
                return


    # STEP 2: Document generation
    async with cl.Step(name="Strategist Agent", type="run") as agent_step:
        # 1. Prepare data for the API
        research_data = {
            "university": cl.user_session.get("uni"),
            "program": cl.user_session.get("program"),
            "level": cl.user_session.get("level"),
            "background": message.content # Sending full user bio as context
        }

        # 2. Call the Agentic Kickoff endpoint
        async with httpx.AsyncClient() as client:
            # We increase timeout because scraping + reasoning takes time
            res = await client.post(
                "http://127.0.0.1:8001/start-research",
                json=research_data,
                timeout=180 
            )
            if res.status_code == 200:
                agent_data = res.json()
                report_content = agent_data.get("report", "No report generated.")
                agent_step.output = f"Strategy for {uni_name} completed."
            else:
                agent_step.output = f"Error: Agent failed to generate strategy."
                return

    # --- STEP 3: Delivery (File Generation & Upload) ---
    # Define the filename and path
    filename = f"{clean_name}.docx"
    file_path = os.path.join(OUTPUT_DIR, filename)
    with open(os.path.join(OUTPUT_DIR, f"{clean_name}.txt"), "w") as f:
        f.write(report_content)
    final_path = os.path.join(OUTPUT_DIR, f"{clean_name}.txt")

    if os.path.exists(final_path):
        await cl.Message(
            content=f"Done! I have compiled the research and strategy for **{uni_name}**. You can download your guide below:",
            elements=[cl.File(name=f"{clean_name}.txt", path=final_path, display="inline")]
        ).send()